# BCTCI: Catalog of Technical Topics

Welcome to the BCTCI (Best Coding Techniques & Concepts Illustrated) repository! This project is a comprehensive collection of C++ implementations and explanations for a wide range of essential technical topics, commonly encountered in coding interviews and computer science courses. Each chapter is dedicated to a specific data structure, algorithm, or programming paradigm, with clear code examples and explanations to help you master these concepts.

## Table of Contents

- [Chapter 25: Dynamic Arrays](./Chapter_25_Dynamic_Arrays)
- [Chapter 26: String Manipulation]
- [Chapter 27: Two Pointers]
- [Chapter 28: Grids & Matrices]
- [Chapter 29: Binary Search]
- [Chapter 30: Sets & Maps]
- [Chapter 31: Sorting]
- [Chapter 32: Stacks & Queues]
- [Chapter 33: Recursion]
- [Chapter 34: Linked Lists]
- [Chapter 35: Trees]
- [Chapter 36: Graphs]
- [Chapter 37: Heaps]
- [Chapter 38: Sliding Windows]
- [Chapter 39: Backtracking]
- [Chapter 40: Dynamic Programming]
- [Chapter 41: Greedy Algorithms]
- [Chapter 42: Topological Sort]
- [Chapter 43: Prefix Sums]

## Chapter Summaries

**Chapter 25: Dynamic Arrays**  
Implementation and usage of dynamic arrays with automatic resizing, supporting efficient append, insert, and delete operations.

**Chapter 26: String Manipulation**  
Techniques and algorithms for processing, searching, and transforming strings, including pattern matching and substring problems.

**Chapter 27: Two Pointers**  
The two-pointer technique for solving array and string problems efficiently, such as finding pairs, reversing, and partitioning.

**Chapter 28: Grids & Matrices**  
Working with 2D arrays, grids, and matrix-based algorithms, including traversals and search techniques.

**Chapter 29: Binary Search**  
Binary search and its applications in searching sorted data, finding boundaries, and solving optimization problems.

**Chapter 30: Sets & Maps**  
Usage of sets, maps, and hash tables for efficient data storage, lookup, and frequency counting.

**Chapter 31: Sorting**  
Classic sorting algorithms (bubble, selection, insertion, merge, quicksort) and their implementations, with complexity analysis.

**Chapter 32: Stacks & Queues**  
Stack and queue data structures, their applications in parsing, backtracking, and breadth/depth-first search.

**Chapter 33: Recursion**  
Recursive problem-solving techniques, including base cases, recursion trees, and common recursive algorithms.

**Chapter 34: Linked Lists**  
Implementation and manipulation of singly and doubly linked lists, including reversal, merging, and cycle detection.

**Chapter 35: Trees**  
Tree data structures, traversals (inorder, preorder, postorder), and common tree algorithms (BST, AVL, etc.).

**Chapter 36: Graphs**  
Graph representations (adjacency list/matrix), traversals (BFS, DFS), and algorithms (shortest path, connectivity).

**Chapter 37: Heaps**  
Heap data structures (min-heap, max-heap), priority queues, and heap-based algorithms (heap sort, top-k elements).

**Chapter 38: Sliding Windows**  
The sliding window technique for efficient subarray and substring problems, including maximum/minimum window and frequency analysis.

**Chapter 39: Backtracking**  
Backtracking algorithms for combinatorial and constraint satisfaction problems, such as permutations, combinations, and sudoku.

**Chapter 40: Dynamic Programming**  
Dynamic programming concepts, memoization, tabulation, and classic DP problems (knapsack, LIS, etc.).

**Chapter 41: Greedy Algorithms**  
Greedy strategies for optimization problems, including interval scheduling, coin change, and activity selection.

**Chapter 42: Topological Sort**  
Topological sorting and its applications in directed acyclic graphs (DAGs), dependency resolution, and scheduling.

**Chapter 43: Prefix Sums**  
Prefix sum techniques for efficient range query problems, including 1D and 2D prefix sums.

## How to Use This Repository

1. **Browse Chapters:** Navigate to the chapter folder of interest to find code and explanations.
2. **Read & Learn:** Each chapter contains C++ code and, where available, a README with explanations and usage examples.
3. **Compile & Run:** Use a C++ compiler (e.g., g++, clang++, or MSVC) to compile and run the code examples on your local machine.
4. **Experiment:** Modify the code or add your own examples to deepen your understanding.

## Requirements

- C++ compiler (g++, clang++, or MSVC recommended)
- Basic knowledge of C++ and command-line usage

## Contributing

Contributions are welcome! Feel free to open issues or submit pull requests to add new chapters, improve explanations, or fix bugs.

## About Me

Hi, I'm Rahul! I'm passionate about algorithms, data structures, and helping others learn computer science fundamentals. You can find more of my work and connect with me here:

- [GitHub](https://github.com/rahul)  
- [LinkedIn](https://www.linkedin.com/in/rahul)  
- [Personal Website](https://rahul.dev)

Thank you for visiting this repository! If you find it helpful, please consider starring or sharing it with others. 